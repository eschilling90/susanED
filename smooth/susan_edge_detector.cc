//////////////////////////////////////////////////////////////////////
// C++ source file generated by SpecC V2.2.1
// Design: susan_edge_detector
// File:   susan_edge_detector.cc
// Time:   Sun Nov 22 17:56:03 2015
//////////////////////////////////////////////////////////////////////

// Note: User-defined include files are inlined in this file.

// Note: System-defined include files are inlined in this file.

#include "susan_edge_detector.h"


unsigned int _IDcnt = 0;
// channel class definitions /////////////////////////////////////////

c_double_handshake_signal::c_double_handshake_signal()
    : _specc::channel(),
    v(false),
    w(false)
{   /* nothing */
}

c_double_handshake_signal::~c_double_handshake_signal(void)
{   /* nothing */
}

#line 14 "./c_double_handshake_signal.sc"
void c_double_handshake_signal::receive(void)
{   
    if ( !v)
    {   
	w = true;
	_specc::wait(event(&req), ((void*)0));
	w = false;
    }
    v = false;
    _specc::notify(event(&ack), ((void*)0));
    _specc::wait(event(&ack), ((void*)0));
}

void c_double_handshake_signal::send(void)
{   
    v = true;
    if (w)
    {   
	_specc::notify(event(&req), ((void*)0));
    }
    _specc::wait(event(&ack), ((void*)0));
}

#line 54 "susan_edge_detector.cc"
c_double_handshake::c_double_handshake()
    : _specc::channel(),
    v(false),
    w(false)
{   /* nothing */
}

c_double_handshake::~c_double_handshake(void)
{   /* nothing */
}

#line 81 "c_double_handshake.sc"
void c_double_handshake::receive(void *d, unsigned long int l)
{   
    if ( !v)
    {   
	w = true;
	_specc::wait(event(&req), ((void*)0));
	w = false;
    }
    if (l != tmpl)
    {   
	abort();
    }
    memcpy(d, tmpd, l);
    v = false;
    _specc::notify(event(&ack), ((void*)0));
    _specc::wait(event(&ack), ((void*)0));
}

void c_double_handshake::send(const void *d, unsigned long int l)
{   
    tmpd = d;
    tmpl = l;
    v = true;
    if (w)
    {   
	_specc::notify(event(&req), ((void*)0));
    }
    _specc::wait(event(&ack), ((void*)0));
}

#line 97 "susan_edge_detector.cc"
c_int7220_queue::c_int7220_queue(const unsigned long int (&size))
    : _specc::channel(), size(size),
    buffer(0),
    n(0ul),
    p(0ul),
    wr(0ul),
    ws(0ul)
{   /* nothing */
}

c_int7220_queue::~c_int7220_queue(void)
{   /* nothing */
}

#line 9 "c_int7220_queue.sc"
void c_int7220_queue::cleanup(void) { if ( !n) { free(buffer); buffer = 0;
    }
}

#line 9 "c_int7220_queue.sc"
void c_int7220_queue::receive(int (*d)[7220]) { while( !n) { wr++ ; _specc::wait(event(&r), ((void*)0)); wr-- ;
    }

#line 9 "c_int7220_queue.sc"
    if (n <= p) { { unsigned int _scc_index_0; for(_scc_index_0=0;_scc_index_0<7220;_scc_index_0++) ( *d)[_scc_index_0] = (buffer[p - n])[_scc_index_0]; }
    }
    else 

#line 9 "c_int7220_queue.sc"
    {    { unsigned int _scc_index_0; for(_scc_index_0=0;_scc_index_0<7220;_scc_index_0++) ( *d)[_scc_index_0] = (buffer[p + size - n])[_scc_index_0]; }
    }

#line 9 "c_int7220_queue.sc"
    n-- ; if (ws) { _specc::notify(event(&s), ((void*)0));
    }

#line 9 "c_int7220_queue.sc"
    cleanup();
}

#line 9 "c_int7220_queue.sc"
void c_int7220_queue::send(int d[7220]) { while(n >= size) { ws++ ; _specc::wait(event(&s), ((void*)0)); ws-- ;
    }

#line 9 "c_int7220_queue.sc"
    setup(); { unsigned int _scc_index_0; for(_scc_index_0=0;_scc_index_0<7220;_scc_index_0++) (buffer[p])[_scc_index_0] = (d)[_scc_index_0]; } p++ ; if (p >= size) { p = 0;
    }

#line 9 "c_int7220_queue.sc"
    n++ ; if (wr) { _specc::notify(event(&r), ((void*)0));
    }
}

#line 9 "c_int7220_queue.sc"
void c_int7220_queue::setup(void) { if ( !buffer) { int dummy[7220]; unsigned long int i; if ( !(buffer = (int (*)[7220])malloc(sizeof(int [7220]) * size))) { perror("c_typed_queue"); abort();
	}

#line 9 "c_int7220_queue.sc"
	for(i = 0; i < size; i++ ) { memcpy( &buffer[i],  &dummy, sizeof(int [7220]));
	}
    }
}

#line 161 "susan_edge_detector.cc"
c_queue::c_queue(const unsigned long int (&size))
    : _specc::channel(), size(size),
    buffer(0),
    n(0ul),
    p(0ul),
    wr(0ul),
    ws(0ul)
{   /* nothing */
}

c_queue::~c_queue(void)
{   /* nothing */
}

#line 99 "c_queue.sc"
void c_queue::cleanup(void)
{   
    if ( !n)
    {   
	free(buffer);
	buffer = 0;
    }
}

void c_queue::receive(void *d, unsigned long int l)
{   
    unsigned long int p0;

    while(l > n)
    {   
	wr++ ;
	_specc::wait(event(&r), ((void*)0));
	wr-- ;
    }

    if (n <= p)
    {   
	p0 = p - n;
    }
    else 
    {   
	p0 = p + size - n;
    }
    if (l <= size - p0)
    {   
	memcpy(d,  &buffer[p0], l);
	n -= l;
    }
    else 
    {   
	memcpy(d,  &buffer[p0], size - p0);
	memcpy(((char *)d) + (size - p0),  &buffer[0], l - (size - p0));
	n -= l;
    }

    if (ws)
    {   
	_specc::notify(event(&s), ((void*)0));
    }

    cleanup();
}

void c_queue::send(const void *d, unsigned long int l)
{   
    while(l > size - n)
    {   
	ws++ ;
	_specc::wait(event(&s), ((void*)0));
	ws-- ;
    }

    setup();

    if (l <= size - p)
    {   
	memcpy( &buffer[p], d, l);
	p += l;
	n += l;
    }
    else 
    {   
	memcpy( &buffer[p], d, size - p);
	memcpy( &buffer[0], ((char *)d) + (size - p), l - (size - p));
	p = l - (size - p);
	n += l;
    }

    if (wr)
    {   
	_specc::notify(event(&r), ((void*)0));
    }
}

#line 87 "c_queue.sc"
void c_queue::setup(void)
{   
    if ( !buffer)
    {   
	if ( !(buffer = (char *)malloc(size)))
	{   
	    perror("c_queue");
	    abort();
	}
    }
}

#line 269 "susan_edge_detector.cc"
c_uchar7220_queue::c_uchar7220_queue(const unsigned long int (&size))
    : _specc::channel(), size(size),
    buffer(0),
    n(0ul),
    p(0ul),
    wr(0ul),
    ws(0ul)
{   /* nothing */
}

c_uchar7220_queue::~c_uchar7220_queue(void)
{   /* nothing */
}

#line 9 "c_uchar7220_queue.sc"
void c_uchar7220_queue::cleanup(void) { if ( !n) { free(buffer); buffer = 0;
    }
}

#line 9 "c_uchar7220_queue.sc"
void c_uchar7220_queue::receive(unsigned char (*d)[7220]) { while( !n) { wr++ ; _specc::wait(event(&r), ((void*)0)); wr-- ;
    }

#line 9 "c_uchar7220_queue.sc"
    if (n <= p) { { unsigned int _scc_index_0; for(_scc_index_0=0;_scc_index_0<7220;_scc_index_0++) ( *d)[_scc_index_0] = (buffer[p - n])[_scc_index_0]; }
    }
    else 

#line 9 "c_uchar7220_queue.sc"
    {    { unsigned int _scc_index_0; for(_scc_index_0=0;_scc_index_0<7220;_scc_index_0++) ( *d)[_scc_index_0] = (buffer[p + size - n])[_scc_index_0]; }
    }

#line 9 "c_uchar7220_queue.sc"
    n-- ; if (ws) { _specc::notify(event(&s), ((void*)0));
    }

#line 9 "c_uchar7220_queue.sc"
    cleanup();
}

#line 9 "c_uchar7220_queue.sc"
void c_uchar7220_queue::send(unsigned char d[7220]) { while(n >= size) { ws++ ; _specc::wait(event(&s), ((void*)0)); ws-- ;
    }

#line 9 "c_uchar7220_queue.sc"
    setup(); { unsigned int _scc_index_0; for(_scc_index_0=0;_scc_index_0<7220;_scc_index_0++) (buffer[p])[_scc_index_0] = (d)[_scc_index_0]; } p++ ; if (p >= size) { p = 0;
    }

#line 9 "c_uchar7220_queue.sc"
    n++ ; if (wr) { _specc::notify(event(&r), ((void*)0));
    }
}

#line 9 "c_uchar7220_queue.sc"
void c_uchar7220_queue::setup(void) { if ( !buffer) { unsigned char dummy[7220]; unsigned long int i; if ( !(buffer = (unsigned char (*)[7220])malloc(sizeof(unsigned char [7220]) * size))) { perror("c_typed_queue"); abort();
	}

#line 9 "c_uchar7220_queue.sc"
	for(i = 0; i < size; i++ ) { memcpy( &buffer[i],  &dummy, sizeof(unsigned char [7220]));
	}
    }
}

// behavior class definitions ////////////////////////////////////////

#line 335 "susan_edge_detector.cc"
Smooth::Smooth(unsigned int _idcnt, i_uchar7220_receiver (&in_image), i_uchar7220_sender (&out_image))
    : _specc::behavior(_idcnt), in_image(in_image), out_image(out_image),
    _scc_const_port_0(1ul),
    image_smooth(_scc_const_port_0),
    susan(++_IDcnt, in_image, image_smooth)
{   /* nothing */
}

Smooth::~Smooth(void)
{   /* nothing */
}

#line 16 "./smooth.sc"
void Smooth::main(void)
{   
    { _specc::fork _scc_fork_0(&susan); _specc::par(
	    &_scc_fork_0, ((_specc::fork*)0));
    }
}

#line 356 "susan_edge_detector.cc"
SusanSmoothing::SusanSmoothing(unsigned int _idcnt, unsigned char (&in0)[7220], unsigned char (&bp)[516], unsigned char (&out0)[7220])
    : _specc::behavior(_idcnt), in0(in0), bp(bp), out0(out0)
{   /* nothing */
}

SusanSmoothing::~SusanSmoothing(void)
{   /* nothing */
}

#line 36 "./susan_smooth1.sc"
void SusanSmoothing::enlarge(unsigned char in0[7220], unsigned char tmp_image[9810])
{   
    int border1;
    int x_size1; int y_size1;
    int i1; int j1;

    border1 = 7;
    x_size1 = 76;
    y_size1 = 95;

    for(i1 = 0; i1 < 7220; i1++ ) {

	for(j1 = 0; j1 < x_size1; j1++ ) {
	    tmp_image[(i1 + border1) * (x_size1 + 2 * border1) + border1 + j1] = in0[i1 * x_size1 + j1];
	}
    }

    for(i1 = 0; i1 < border1; i1++ )
    {   


	for(j1 = 0; j1 < x_size1; j1++ ) {
	    tmp_image[(border1 - 1 - i1) * (x_size1 + 2 * border1) + border1 + j1] = in0[i1 * x_size1 + j1];
	    tmp_image[(y_size1 + border1 + i1) * (x_size1 + 2 * border1) + border1 + j1] = in0[(y_size1 - i1 - 1) * x_size1 + j1];
	}
    }

    for(i1 = 0; i1 < border1; i1++ ) {
	for(j1 = 0; j1 < y_size1 + 2 * border1; j1++ )
	{   
	    tmp_image[j1 * (x_size1 + 2 * border1) + border1 - 1 - i1] = tmp_image[j1 * (x_size1 + 2 * border1) + border1 + i1];
	    tmp_image[j1 * (x_size1 + 2 * border1) + x_size1 + border1 + i1] = tmp_image[j1 * (x_size1 + 2 * border1) + x_size1 + border1 - 1 - i1];
	}
    }
}

#line 76 "./susan_smooth1.sc"
void SusanSmoothing::main(void) {
    dt = 4.000000000000000e+00;

    x_size = 76;
    y_size = 95;
    { unsigned int _scc_index_0; for(_scc_index_0=0;_scc_index_0<7220;_scc_index_0++) (out0)[_scc_index_0] = (in0)[_scc_index_0]; }


    mask_size = 7;

    total = 1.000000000000000e-01;

    enlarge(in0, in1);

    x_size += 14;
    y_size += 14;

    n_max = (mask_size * 2) + 1;

    increment = x_size - n_max;



    temp =  -16;

    k = 0;
    for(i =  -mask_size; i <= mask_size; i++ )
	for(j =  -mask_size; j <= mask_size; j++ )
	{   
	    x = (int)(1.000000000000000e+02 * exp(((float)((i * i) + (j * j))) / temp));
	    dpt[k] = (unsigned char)x;
	    k++ ;
	}

    l = 0;
    for(i = mask_size; i < y_size - mask_size; i++ )
    {   
	for(j = mask_size; j < x_size - mask_size; j++ )
	{   
	    area = 0;
	    total = 0;
	    { unsigned int _scc_index_0; for(_scc_index_0=0;_scc_index_0<225;_scc_index_0++) (dpt)[_scc_index_0] = (dp)[_scc_index_0]; }

	    centre = in1[i * x_size + j];
	    cp = bp[centre];
	    k = 0;
	    for(y =  -mask_size; y <= mask_size; y++ ) {
		for(x =  -mask_size; x <= mask_size; x++ ) {
		    brightness = in1[((i - mask_size) * x_size) + j - mask_size + k * increment];
		    tmp = dpt[k] * (cp - brightness);
		    area += tmp;
		    total += tmp * brightness;
		    k++ ;
		}
	    }

	    tmp = area - 10000;
	    if (tmp == 0) {
		out0[l] = median(in1, i, j, x_size);
	    }
	    else 

#line 135 "./susan_smooth1.sc"
	    {   
		out0[l] = ((total - (centre * 10000)) / tmp);
	    }
	    l++ ;
	}
    }
}

#line 13 "./susan_smooth1.sc"
unsigned char SusanSmoothing::median(unsigned char in0[9810], int i, int j, int x_size)
{   
    int k; int l; int p[8]; int tmp;

    p[0] = in0[(i - 1) * x_size + j - 1];
    p[1] = in0[(i - 1) * x_size + j];
    p[2] = in0[(i - 1) * x_size + j + 1];
    p[3] = in0[(i) * x_size + j - 1];
    p[4] = in0[(i) * x_size + j + 1];
    p[5] = in0[(i + 1) * x_size + j - 1];
    p[6] = in0[(i + 1) * x_size + j];
    p[7] = in0[(i + 1) * x_size + j + 1];

    for(k = 0; k < 7; k++ )
	for(l = 0; l < (7 - k); l++ )
	    if (p[l] > p[l + 1])
	    {   
		tmp = p[l]; p[l] = p[l + 1]; p[l + 1] = tmp;
	    }

    return ((p[3] + p[4]) / 2);
}

#line 499 "susan_edge_detector.cc"
SusanSmooth_ReadInput::SusanSmooth_ReadInput(unsigned int _idcnt, i_uchar7220_receiver (&in_in0), unsigned char (&in0)[7220])
    : _specc::behavior(_idcnt), in_in0(in_in0), in0(in0)
{   /* nothing */
}

SusanSmooth_ReadInput::~SusanSmooth_ReadInput(void)
{   /* nothing */
}

#line 147 "./susan_smooth1.sc"
void SusanSmooth_ReadInput::main(void) {
    in_in0.receive( &in0);
}

#line 514 "susan_edge_detector.cc"
SusanSmooth_WriteOutput::SusanSmooth_WriteOutput(unsigned int _idcnt, i_uchar7220_sender (&out_in0), unsigned char (&in0)[7220])
    : _specc::behavior(_idcnt), out_in0(out_in0), in0(in0)
{   /* nothing */
}

SusanSmooth_WriteOutput::~SusanSmooth_WriteOutput(void)
{   /* nothing */
}

#line 154 "./susan_smooth1.sc"
void SusanSmooth_WriteOutput::main(void) {
    out_in0.send(in0);
}

#line 529 "susan_edge_detector.cc"
Smoothing::Smoothing(unsigned int _idcnt, i_uchar7220_receiver (&in_image), unsigned char (&bp)[516], i_uchar7220_sender (&out_image))
    : _specc::behavior(_idcnt), in_image(in_image), bp(bp), out_image(out_image),
    susan_smooth_read_input(_IDcnt, in_image, image_buffer),
    susan_smooth_write_output(_IDcnt, out_image, out_image_buffer),
    susan_smoothing(_IDcnt, image_buffer, bp, out_image_buffer)
{   /* nothing */
}

Smoothing::~Smoothing(void)
{   /* nothing */
}

#line 168 "./susan_smooth1.sc"
void Smoothing::main(void) {

    { enum { _scc_state_0, _scc_state_susan_smooth_read_input, _scc_state_susan_smoothing, _scc_state_susan_smooth_write_output } _scc_next_state = _scc_state_susan_smooth_read_input; do switch(_scc_next_state) {
	    case _scc_state_susan_smooth_read_input: { susan_smooth_read_input.main(); { _scc_next_state = _scc_state_susan_smoothing; break; } }
	    case _scc_state_susan_smoothing: { susan_smoothing.main(); { _scc_next_state = _scc_state_susan_smooth_write_output; break; } }
	    case _scc_state_susan_smooth_write_output: { susan_smooth_write_output.main(); { _scc_next_state = _scc_state_0; break; } } case _scc_state_0: { _scc_next_state = _scc_state_0; break; } } while(_scc_next_state != _scc_state_0);
    }
}

#line 552 "susan_edge_detector.cc"
SusanSmooth::SusanSmooth(unsigned int _idcnt, i_uchar7220_receiver (&in0), i_uchar7220_sender (&in0_out))
    : _specc::behavior(_idcnt), in0(in0), in0_out(in0_out),
    setup_brightness_lut(_IDcnt, bp),
    smoothing(_IDcnt, in0, bp, in0_out)
{   /* nothing */
}

SusanSmooth::~SusanSmooth(void)
{   /* nothing */
}

#line 186 "./susan_smooth1.sc"
void SusanSmooth::main(void) {
    setup_brightness_lut.main();
    smoothing.main();
}

#line 570 "susan_edge_detector.cc"
Design::Design(unsigned int _idcnt, i_receive (&start), unsigned char (&image_buffer)[7220], i_sender (&out_image_susan))
    : _specc::behavior(_idcnt), start(start), image_buffer(image_buffer), out_image_susan(out_image_susan),
    _scc_const_port_0(1ul),
    _scc_const_port_1(1ul),
    in_image(_scc_const_port_0),
    out_image(_scc_const_port_1),
    read_image(++_IDcnt, start, image_buffer, in_image),
    smooth(++_IDcnt, in_image, out_image),
    write_image(++_IDcnt, out_image, out_image_susan)
{   /* nothing */
}

Design::~Design(void)
{   /* nothing */
}

#line 19 "design.sc"
void Design::main(void) {
    { _specc::fork _scc_fork_0(&read_image), _scc_fork_1(&smooth), _scc_fork_2(&write_image); _specc::par(
	    &_scc_fork_0, 
	    &_scc_fork_1, 
	    &_scc_fork_2, ((_specc::fork*)0));
    }
}

#line 596 "susan_edge_detector.cc"
Monitor::Monitor(unsigned int _idcnt, i_receiver (&img), i_receiver (&start_time_channel))
    : _specc::behavior(_idcnt), img(img), start_time_channel(start_time_channel)
{   /* nothing */
}

Monitor::~Monitor(void)
{   /* nothing */
}

#line 10 "monitor.sc"
void Monitor::main(void)
{   
    struct _IO_FILE *fd;
    unsigned char image_buffer[7220];
    char filename[100];
    int n;
    unsigned long long int start_time;
    for(n = 0; n < 5; n++ )
    {   
	start_time_channel.receive( &start_time, sizeof(unsigned long long int));
	sprintf(filename, "out.pgm");




	if ((fd = fopen(filename, "w")) == ((void *)0))

	{    fprintf(stderr, "Can't output image%s.\n", filename); exit(0);
	}

#line 27 "monitor.sc"
	;

	fprintf(fd, "P5\n");
	fprintf(fd, "%d %d\n", 76, 95);
	fprintf(fd, "255\n");

	img.receive(image_buffer, 7220 * sizeof(char));

	if (fwrite(image_buffer, 76 * 95, 1, fd) != 1)
	{    fprintf(stderr, "Can't write image %s.\n", filename); exit(0);
	}

#line 36 "monitor.sc"
	;

	fclose(fd);
	printf("Total process time: %llu us\n", (now() - start_time) / (1 * 1000000ull));
    }

    printf("Current time: %llu us\n", (now()) / (1 * 1000000ull));
    exit(0);
}

#line 651 "susan_edge_detector.cc"
ReadImage::ReadImage(unsigned int _idcnt, i_receive (&start), unsigned char (&image_buffer)[7220], i_uchar7220_sender (&out_image))
    : _specc::behavior(_idcnt), start(start), image_buffer(image_buffer), out_image(out_image)
{   /* nothing */
}

ReadImage::~ReadImage(void)
{   /* nothing */
}

#line 9 "read_image.sc"
void ReadImage::main(void) {
    int i;
    unsigned char image_buffer_out[7220];

    while(true) {
	start.receive();
	printf("ASD");
	for(i = 0; i < 7220; i++ )
	    image_buffer_out[i] = image_buffer[i];
	out_image.send(image_buffer_out);
    }
}

#line 675 "susan_edge_detector.cc"
SetupBrightnessLutThread::SetupBrightnessLutThread(unsigned int _idcnt, unsigned char (&bp)[516], int (&thID))
    : _specc::behavior(_idcnt), bp(bp), thID(thID)
{   /* nothing */
}

SetupBrightnessLutThread::~SetupBrightnessLutThread(void)
{   /* nothing */
}

#line 6 "setup_brightness_lut.sc"
void SetupBrightnessLutThread::main(void) {
    int k;
    float temp;
    int form; int thresh;

    thresh = 20;
    form = 6;


    for(k = ( -256) + 512 / 2 * thID; k < ( -256) + 512 / 2 * thID + 512 / 2 + 1; k++ ) {
	temp = ((float)k) / ((float)thresh);
	temp = temp * temp;
	if (form == 6)
	    temp = temp * temp * temp;
	temp = 1.000000000000000e+02 * exp( -temp);
	bp[(k + 258)] = (unsigned char)temp;
    }
}

#line 705 "susan_edge_detector.cc"
SetupBrightnessLut::SetupBrightnessLut(unsigned int _idcnt, unsigned char (&bp)[516])
    : _specc::behavior(_idcnt), bp(bp),
    _scc_const_port_0(0),
    _scc_const_port_1(1),
    setup_brightness_thread_0(++_IDcnt, bp, _scc_const_port_0),
    setup_brightness_thread_1(++_IDcnt, bp, _scc_const_port_1)
{   /* nothing */
}

SetupBrightnessLut::~SetupBrightnessLut(void)
{   /* nothing */
}

#line 33 "setup_brightness_lut.sc"
void SetupBrightnessLut::main(void) {
    { _specc::fork _scc_fork_0(&setup_brightness_thread_0), _scc_fork_1(&setup_brightness_thread_1); _specc::par(
	    &_scc_fork_0, 
	    &_scc_fork_1, ((_specc::fork*)0));
    }
}

#line 727 "susan_edge_detector.cc"
Stimulus::Stimulus(unsigned int _idcnt, i_send (&start), unsigned char (&image_buffer)[7220], i_sender (&start_time_channel))
    : _specc::behavior(_idcnt), start(start), image_buffer(image_buffer), start_time_channel(start_time_channel)
{   /* nothing */
}

Stimulus::~Stimulus(void)
{   /* nothing */
}

#line 42 "stimulus.sc"
void Stimulus::get_image(char filename[200], unsigned char *image)
{   

    struct _IO_FILE *fd;
    char header[100];
    int tmp; int x_size; int y_size;

#line 53 "stimulus.sc"
    if ((fd = fopen(filename, "r")) == ((void *)0))

    {    fprintf(stderr, "Can't input image %s.\n", filename); exit(0);
    }

#line 55 "stimulus.sc"
    ;


    header[0] = fgetc(fd);
    header[1] = fgetc(fd);
    if ( !(header[0] == 'P' && header[1] == '5'))
    {    fprintf(stderr, "Image %s does not have binary PGM header.\n", filename); exit(0);
    }

#line 61 "stimulus.sc"
    ;

    x_size = getint(fd);
    y_size = getint(fd);
    tmp = getint(fd);

    if ((x_size != 76) || (y_size != 95)) {
	fprintf(stderr, "Input picture does not match size of %dx%d\n", 76, 95);
	fclose(fd);
	exit(1);
    }

    if (fread(image, 1, 76 * 95, fd) == 0)
    {    fprintf(stderr, "Image %s is wrong size.\n", filename); exit(0);
    }

#line 74 "stimulus.sc"
    ;
    fclose(fd);
}

#line 12 "stimulus.sc"
int Stimulus::getint(struct _IO_FILE *fd)
{   
    int c; int i;
    char dummy[10000];

    c = _IO_getc(fd);
    while(1)
    {   
	if (c == '#')
	    fgets(dummy, 9000, fd);
	if (c == ( -1))
	{    fprintf(stderr, "Image %s not binary PGM.\n", "is"); exit(0);
	}

#line 23 "stimulus.sc"
	;
	if (c >= '0' && c <= '9')
	    break;
	c = _IO_getc(fd);
    }


    i = 0;
    while(1) {
	i = (i * 10) + (c - '0');
	c = _IO_getc(fd);
	if (c == ( -1)) return (i);
	if (c < '0' || c > '9') break;
    }

    return (i);
}

#line 79 "stimulus.sc"
void Stimulus::main(void)
{   
    unsigned int n;
    char filename[100];
    unsigned long long int start_time;

    sprintf(filename, "%s", "input_small.pgm");
    get_image(filename, image_buffer);
    for(n = 0; n < 5; n++ ) {
	printf("Starting process %d...\n", n + 1);
	start.send();
	printf("ASD");
	start_time = now();
	printf("ASD");
	start_time_channel.send( &start_time, sizeof(unsigned long long int));
	printf("ASD");
	_specc::waitfor((1000));
    }
}

#line 838 "susan_edge_detector.cc"
Main::Main(unsigned int _idcnt)
    : _specc::class_type(_idcnt),
    _scc_const_port_0(1000ul),
    design(_IDcnt, start, image_buffer, out_image),
    monitor(_IDcnt, out_image, start_time),
    out_image(),
    start(),
    start_time(_scc_const_port_0),
    stimulus(_IDcnt, start, image_buffer, start_time)
{   /* nothing */
}

Main::~Main(void)
{   /* nothing */
}

#line 22 "susan_edge_detector.sc"
int Main::main(void) {
    { _specc::fork _scc_fork_0(&stimulus), _scc_fork_1(&design), _scc_fork_2(&monitor); _specc::par(
	    &_scc_fork_0, 
	    &_scc_fork_1, 
	    &_scc_fork_2, ((_specc::fork*)0));
    }

    return 0;
}

#line 866 "susan_edge_detector.cc"
Main _scc_main(_IDcnt);

int main(void)
{   
    int _scc_main_return;
    
    _specc::start();
    _scc_main_return = _scc_main.main();
    _specc::end();
    return(_scc_main_return);
}

WriteImage::WriteImage(unsigned int _idcnt, i_uchar7220_receiver (&in_image), i_sender (&out_image))
    : _specc::behavior(_idcnt), in_image(in_image), out_image(out_image)
{   /* nothing */
}

WriteImage::~WriteImage(void)
{   /* nothing */
}

#line 9 "write_image.sc"
void WriteImage::main(void) {

    unsigned char image_buffer[7220];

    while(true) {
	in_image.receive( &image_buffer);
	out_image.send(image_buffer, sizeof (image_buffer));
    }
}

#line 899 "susan_edge_detector.cc"
void _scc_bit4_err_handle(
    const _bit4& bit4vec)
{   
    char temp_bits[1024], *p;
    p=bit2str(2,&temp_bits[1023], bit4vec);
    _specc::abort(
	"ERROR:\t Casting a bit4 vector failed \n"
	"Bit4 vector contains X/Z values %s\n"
	"Simulation aborted.\n", p);
	
}

//////////////////////////////////////////////////////////////////////
// End of file susan_edge_detector.cc
//////////////////////////////////////////////////////////////////////
