//////////////////////////////////////////////////////////////////////
// C++ source file generated by SpecC V2.2.1
// Design: susan_edge_detector
// File:   susan_edge_detector.cc
// Time:   Sat Sep 26 13:09:24 2015
//////////////////////////////////////////////////////////////////////

// Note: User-defined include files are inlined in this file.

// Note: System-defined include files are inlined in this file.

#include "susan_edge_detector.h"


unsigned int _IDcnt = 0;
// channel class definitions /////////////////////////////////////////

c_double_handshake::c_double_handshake()
    : _specc::channel(),
    v(false),
    w(false)
{   /* nothing */
}

c_double_handshake::~c_double_handshake(void)
{   /* nothing */
}

#line 81 "c_double_handshake.sc"
void c_double_handshake::receive(void *d, unsigned long int l)
{   
    if ( !v)
    {   
	w = true;
	_specc::wait(event(&req), ((void*)0));
	w = false;
    }
    if (l != tmpl)
    {   
	abort();
    }
    memcpy(d, tmpd, l);
    v = false;
    _specc::notify(event(&ack), ((void*)0));
    _specc::wait(event(&ack), ((void*)0));
}

void c_double_handshake::send(const void *d, unsigned long int l)
{   
    tmpd = d;
    tmpl = l;
    v = true;
    if (w)
    {   
	_specc::notify(event(&req), ((void*)0));
    }
    _specc::wait(event(&ack), ((void*)0));
}

#line 61 "susan_edge_detector.cc"
c_handshake::c_handshake()
    : _specc::channel(),
    f(false),
    w(false)
{   /* nothing */
}

c_handshake::~c_handshake(void)
{   /* nothing */
}

#line 62 "c_handshake.sc"
void c_handshake::receive(void)
{   
    if ( !f)
    {   
	w = true;
	_specc::wait(event(&e), ((void*)0));
	w = false;
    }
    f = false;
}

void c_handshake::send(void)
{   
    if (w)
    {   
	_specc::notify(event(&e), ((void*)0));
    }
    f = true;
}

#line 94 "susan_edge_detector.cc"
c_queue::c_queue(const unsigned long int (&size))
    : _specc::channel(), size(size),
    buffer(0),
    n(0ul),
    p(0ul),
    wr(0ul),
    ws(0ul)
{   /* nothing */
}

c_queue::~c_queue(void)
{   /* nothing */
}

#line 99 "c_queue.sc"
void c_queue::cleanup(void)
{   
    if ( !n)
    {   
	free(buffer);
	buffer = 0;
    }
}

void c_queue::receive(void *d, unsigned long int l)
{   
    unsigned long int p0;

    while(l > n)
    {   
	wr++ ;
	_specc::wait(event(&r), ((void*)0));
	wr-- ;
    }

    if (n <= p)
    {   
	p0 = p - n;
    }
    else 
    {   
	p0 = p + size - n;
    }
    if (l <= size - p0)
    {   
	memcpy(d,  &buffer[p0], l);
	n -= l;
    }
    else 
    {   
	memcpy(d,  &buffer[p0], size - p0);
	memcpy(((char *)d) + (size - p0),  &buffer[0], l - (size - p0));
	n -= l;
    }

    if (ws)
    {   
	_specc::notify(event(&s), ((void*)0));
    }

    cleanup();
}

void c_queue::send(const void *d, unsigned long int l)
{   
    while(l > size - n)
    {   
	ws++ ;
	_specc::wait(event(&s), ((void*)0));
	ws-- ;
    }

    setup();

    if (l <= size - p)
    {   
	memcpy( &buffer[p], d, l);
	p += l;
	n += l;
    }
    else 
    {   
	memcpy( &buffer[p], d, size - p);
	memcpy( &buffer[0], ((char *)d) + (size - p), l - (size - p));
	p = l - (size - p);
	n += l;
    }

    if (wr)
    {   
	_specc::notify(event(&r), ((void*)0));
    }
}

#line 87 "c_queue.sc"
void c_queue::setup(void)
{   
    if ( !buffer)
    {   
	if ( !(buffer = (char *)malloc(size)))
	{   
	    perror("c_queue");
	    abort();
	}
    }
}

// behavior class definitions ////////////////////////////////////////

#line 204 "susan_edge_detector.cc"
design::design(unsigned int _idcnt, i_receive (&port_start), i_receiver (&port_in_stim), i_sender (&port_out_monitor))
    : _specc::behavior(_idcnt), port_start(port_start), port_in_stim(port_in_stim), port_out_monitor(port_out_monitor),
    _scc_const_port_0(7220ul),
    _scc_const_port_1(7220ul),
    com_read_susan(_scc_const_port_0),
    com_susan_write(_scc_const_port_1),
    readImage(++_IDcnt, port_start, port_in_stim, com_read_susan),
    susanBlock(++_IDcnt, com_read_susan, com_susan_write),
    writeImage(++_IDcnt, com_susan_write, port_out_monitor)
{   /* nothing */
}

design::~design(void)
{   /* nothing */
}

#line 22 "design.sc"
void design::main(void)
{   
    { _specc::fork _scc_fork_0(&readImage), _scc_fork_1(&susanBlock), _scc_fork_2(&writeImage); _specc::par(

	    &_scc_fork_0, 
	    &_scc_fork_1, 
	    &_scc_fork_2, ((_specc::fork*)0));
    }
}

#line 232 "susan_edge_detector.cc"
detect_edges::detect_edges(unsigned int _idcnt, i_receiver (&port_in1), i_sender (&port_in2), i_sender (&port_r), i_sender (&port_mid1))
    : _specc::behavior(_idcnt), port_in1(port_in1), port_in2(port_in2), port_r(port_r), port_mid1(port_mid1),
    _scc_const_port_0(516ul),
    com_bp(_scc_const_port_0),
    setupBrightnessLut(_IDcnt, com_bp),
    susanEdges(_IDcnt, port_in1, port_in2, port_r, port_mid1, com_bp)
{   /* nothing */
}

detect_edges::~detect_edges(void)
{   /* nothing */
}

#line 13 "detect_edges.sc"
void detect_edges::main(void)
{   
    setupBrightnessLut.main();
    susanEdges.main();
}

#line 253 "susan_edge_detector.cc"
edge_draw::edge_draw(unsigned int _idcnt, i_receiver (&port_mid2), i_receiver (&port_in2), i_sender (&port_in3))
    : _specc::behavior(_idcnt), port_mid2(port_mid2), port_in2(port_in2), port_in3(port_in3)
{   
    char _scc_init_filename[] = 

#line 20 "edge_draw.sc"
    "array_in3";
    
    {   unsigned int _scc_index_0;
	for(_scc_index_0 = 0; _scc_index_0 < 10; _scc_index_0++)
	    filename[_scc_index_0] = _scc_init_filename[_scc_index_0];
    }
}

#line 268 "susan_edge_detector.cc"
edge_draw::~edge_draw(void)
{   /* nothing */
}

#line 22 "edge_draw.sc"
void edge_draw::main(void)
{   
    port_in2.receive(in2, 76 * 95 * sizeof(unsigned char));
    printf("in2 is received\n");
    port_mid2.receive(mid, 76 * 95 * sizeof(unsigned char));
    printf("mid2 is received\n");



    if ((fd = fopen(filename, "w")) == ((void *)0))

	printf("Can't output image %s (exit_error used to be here).\n", filename);



    midp = mid;
    for(i = 0; i < 76 * 95; i++ )
    {   
	if ( *midp < 8)
	{   
	    inp = in2 + (midp - mid) - 76 - 1;
	     *inp++  = 255;  *inp++  = 255;  *inp = 255; inp += 76 - 2;
	     *inp++  = 255;  *inp++ ;  *inp = 255; inp += 76 - 2;
	     *inp++  = 255;  *inp++  = 255;  *inp = 255;
	}
	midp++ ;
    }



    midp = mid;
    for(i = 0; i < 76 * 95; i++ )
    {   
	if ( *midp < 8)
	     *(in2 + (midp - mid)) = 0;
	midp++ ;
    }

    for(j = 0; j < 76 * 95; j++ )
    {   
	fprintf(fd, "%c", in2[j]);
	fprintf(fd, "\n");
    }

    fclose(fd);

    printf("start to send in3\n");
    port_in3.send(in2, 76 * 95 * sizeof(unsigned char));
    printf("in3 is sent\n");
}

#line 325 "susan_edge_detector.cc"
monitor::monitor(unsigned int _idcnt, i_receiver (&port_in3))
    : _specc::behavior(_idcnt), port_in3(port_in3)
{   
    char _scc_init_filename[] = 

#line 15 "monitor.sc"
    "out.pgm";
    
    {   unsigned int _scc_index_0;
	for(_scc_index_0 = 0; _scc_index_0 < 8; _scc_index_0++)
	    filename[_scc_index_0] = _scc_init_filename[_scc_index_0];
    }
}

#line 340 "susan_edge_detector.cc"
monitor::~monitor(void)
{   /* nothing */
}

#line 19 "monitor.sc"
void monitor::main(void)
{   
    port_in3.receive(in3, 76 * 95 * sizeof(unsigned char));
    printf("in3 is received\n");




    if ((fd = fopen(filename, "w")) == ((void *)0))

	printf("Can't output image %s (exit_error used to be here).\n", filename);


    fprintf(fd, "P5\n");
    fprintf(fd, "%d %d\n", 76, 95);
    fprintf(fd, "255\n");

    if (fwrite(in3, 76 * 95, 1, fd) != 1)
	printf("Can't write image %s (exit_error used to be here).\n", filename);


    fclose(fd);
    printf("output is written to %s\n", "out.pgm");
    printf("Time%4s: Finished!\n", time2str(buf, now()));

    exit(0);
}

#line 374 "susan_edge_detector.cc"
read_image::read_image(unsigned int _idcnt, i_receive (&port_start), i_receiver (&port_in_stim), i_sender (&port_in1))
    : _specc::behavior(_idcnt), port_start(port_start), port_in_stim(port_in_stim), port_in1(port_in1)
{   /* nothing */
}

read_image::~read_image(void)
{   /* nothing */
}

#line 13 "read_image.sc"
void read_image::main(void)
{   
    port_start.receive();

    port_in_stim.receive(in_stim, 76 * 95 * sizeof(char));
    port_in1.send(in_stim, 76 * 95 * sizeof(char));
}

#line 393 "susan_edge_detector.cc"
setup_brightness_lut::setup_brightness_lut(unsigned int _idcnt, i_sender (&port_bp))
    : _specc::behavior(_idcnt), port_bp(port_bp),
    thresh(20)
{   /* nothing */
}

setup_brightness_lut::~setup_brightness_lut(void)
{   /* nothing */
}

#line 13 "setup_brightness_lut.sc"
void setup_brightness_lut::main(void)
{   
    printf("start setup lut\n");
    for(k =  -256; k < 257; k++ )
    {   
	temp = ((float)k) / ((float)thresh);
	temp = temp * temp;
	temp = temp * temp * temp;
	temp = 1.000000000000000e+02 * exp( -temp);
	bp[k + 258] = (unsigned char)temp;
    }
    port_bp.send(bp, 516 * sizeof(unsigned char));
    printf("bp is sent\n");
}

#line 420 "susan_edge_detector.cc"
stimulus::stimulus(unsigned int _idcnt, i_send (&port_start), i_sender (&port_in1))
    : _specc::behavior(_idcnt), port_start(port_start), port_in1(port_in1)
{   /* nothing */
}

stimulus::~stimulus(void)
{   /* nothing */
}

#line 16 "stimulus.sc"
void stimulus::main(void)
{   

    struct _IO_FILE *fd;

    char dummy[1000]; char header[100];

#line 31 "stimulus.sc"
    if ((fd = fopen("input_small.pgm", "r")) == ((void *)0))



	printf("Can't input image %s.\n (exit_error used to be here)\n", filename);




    header[0] = fgetc(fd);
    header[1] = fgetc(fd);
    if ( !(header[0] == 'P' && header[1] == '5'))
	printf("Image %s does not have binary PGM header (exit_error used to be here)\n", filename);



    fgets(dummy, 1000, fd);
    fgets(dummy, 1000, fd);
    fgets(dummy, 1000, fd);
    fgets(dummy, 1000, fd);

#line 63 "stimulus.sc"
    if (fread(in1, 1, 76 * 95, fd) == 0)

	printf("Image %s is the wrong size (exit_error used to be here)\n", filename);


    fclose(fd);

    port_start.send();
    printf("start signal is sent\n");
    port_in1.send(in1, 76 * 95 * sizeof(unsigned char));
    printf("in1 is sent\n");
}

#line 474 "susan_edge_detector.cc"
susan::susan(unsigned int _idcnt, i_receiver (&port_in1), i_sender (&port_in3))
    : _specc::behavior(_idcnt), port_in1(port_in1), port_in3(port_in3),
    _scc_const_port_0(7220ul),
    _scc_const_port_1(7220ul),
    _scc_const_port_2(7220ul),
    _scc_const_port_3(28880ul),
    com_in2(_scc_const_port_0),
    com_mid1(_scc_const_port_1),
    com_mid2(_scc_const_port_2),
    com_r(_scc_const_port_3),
    detectEdges(_IDcnt, port_in1, com_in2, com_r, com_mid1),
    edgeDraw(_IDcnt, com_mid2, com_in2, port_in3),
    susanThin(_IDcnt, com_r, com_mid1, com_mid2)
{   /* nothing */
}

susan::~susan(void)
{   /* nothing */
}

#line 25 "susan.sc"
void susan::main(void)
{   
    { enum { _scc_state_0, _scc_state_detectEdges, _scc_state_susanThin, _scc_state_edgeDraw } _scc_next_state = _scc_state_detectEdges; do switch(_scc_next_state) {
	    case _scc_state_detectEdges: { detectEdges.main(); { _scc_next_state = _scc_state_susanThin; break; } }
	    case _scc_state_susanThin: { susanThin.main(); { _scc_next_state = _scc_state_edgeDraw; break; } }
	    case _scc_state_edgeDraw: { edgeDraw.main(); { _scc_next_state = _scc_state_detectEdges; break; } } case _scc_state_0: { _scc_next_state = _scc_state_0; break; } } while(_scc_next_state != _scc_state_0);
    }
}

#line 505 "susan_edge_detector.cc"
Main::Main(unsigned int _idcnt)
    : _specc::class_type(_idcnt),
    des(_IDcnt, susan_start, image_in, image_out),
    image_in(),
    image_out(),
    mon(_IDcnt, image_out),
    stim(_IDcnt, susan_start, image_in),
    susan_start()
{   /* nothing */
}

Main::~Main(void)
{   /* nothing */
}

#line 21 "susan_edge_detector.sc"
int Main::main(void)
{   
    { _specc::fork _scc_fork_0(&stim), _scc_fork_1(&des), _scc_fork_2(&mon); _specc::par(
	    &_scc_fork_0, 

	    &_scc_fork_1, 
	    &_scc_fork_2, ((_specc::fork*)0));
    }
    return 0;
}

#line 533 "susan_edge_detector.cc"
Main _scc_main(_IDcnt);

int main(void)
{   
    int _scc_main_return;
    
    _specc::start();
    _scc_main_return = _scc_main.main();
    _specc::end();
    return(_scc_main_return);
}

susan_edges::susan_edges(unsigned int _idcnt, i_receiver (&port_in1), i_sender (&port_in2), i_sender (&port_r), i_sender (&port_mid1), i_receiver (&port_bp))
    : _specc::behavior(_idcnt), port_in1(port_in1), port_in2(port_in2), port_r(port_r), port_mid1(port_mid1), port_bp(port_bp),
    max_no(2650)
{   /* nothing */
}

susan_edges::~susan_edges(void)
{   /* nothing */
}

#line 24 "susan_edges.sc"
void susan_edges::main(void)
{   
    printf("start susan_edges\n");
    port_in1.receive(in1, 76 * 95 * sizeof(unsigned char));
    printf("in1 is received\n");
    port_bp.receive(bp, 516 * sizeof(unsigned char));
    printf("bp is received\n");

    memset(mid, 100, 76 * 95);
    memset(r, 0, 76 * 95 * sizeof(int));

    for(i = 3; i < 95 - 3; i++ )
	for(j = 3; j < 76 - 3; j++ )
	{   
	    n = 100;
	    p = in1 + (i - 3) * 76 + j - 1;
	    cp = bp + 258 + in1[i * 76 + j];

	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p);
	    p += 76 - 3;

	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p);
	    p += 76 - 5;

	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p);
	    p += 76 - 6;

	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p);
	    p += 2;
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p);
	    p += 76 - 6;

	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p);
	    p += 76 - 5;

	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p);
	    p += 76 - 3;

	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p++ );
	    n +=  *(cp -  *p);

	    if (n <= max_no)
		r[i * 76 + j] = max_no - n;
	}

    for(i = 4; i < 95 - 4; i++ )
	for(j = 4; j < 76 - 4; j++ )
	{   
	    if (r[i * 76 + j] > 0)
	    {   
		m = r[i * 76 + j];
		n = max_no - m;
		cp = bp + 258 + in1[i * 76 + j];

		if (n > 600)
		{   
		    p = in1 + (i - 3) * 76 + j - 1;
		    x = 0; y = 0;

		    c =  *(cp -  *p++ ); x -= c; y -= 3 * c;
		    c =  *(cp -  *p++ ); y -= 3 * c;
		    c =  *(cp -  *p); x += c; y -= 3 * c;
		    p += 76 - 3;

		    c =  *(cp -  *p++ ); x -= 2 * c; y -= 2 * c;
		    c =  *(cp -  *p++ ); x -= c; y -= 2 * c;
		    c =  *(cp -  *p++ ); y -= 2 * c;
		    c =  *(cp -  *p++ ); x += c; y -= 2 * c;
		    c =  *(cp -  *p); x += 2 * c; y -= 2 * c;
		    p += 76 - 5;

		    c =  *(cp -  *p++ ); x -= 3 * c; y -= c;
		    c =  *(cp -  *p++ ); x -= 2 * c; y -= c;
		    c =  *(cp -  *p++ ); x -= c; y -= c;
		    c =  *(cp -  *p++ ); y -= c;
		    c =  *(cp -  *p++ ); x += c; y -= c;
		    c =  *(cp -  *p++ ); x += 2 * c; y -= c;
		    c =  *(cp -  *p); x += 3 * c; y -= c;
		    p += 76 - 6;

		    c =  *(cp -  *p++ ); x -= 3 * c;
		    c =  *(cp -  *p++ ); x -= 2 * c;
		    c =  *(cp -  *p); x -= c;
		    p += 2;
		    c =  *(cp -  *p++ ); x += c;
		    c =  *(cp -  *p++ ); x += 2 * c;
		    c =  *(cp -  *p); x += 3 * c;
		    p += 76 - 6;

		    c =  *(cp -  *p++ ); x -= 3 * c; y += c;
		    c =  *(cp -  *p++ ); x -= 2 * c; y += c;
		    c =  *(cp -  *p++ ); x -= c; y += c;
		    c =  *(cp -  *p++ ); y += c;
		    c =  *(cp -  *p++ ); x += c; y += c;
		    c =  *(cp -  *p++ ); x += 2 * c; y += c;
		    c =  *(cp -  *p); x += 3 * c; y += c;
		    p += 76 - 5;

		    c =  *(cp -  *p++ ); x -= 2 * c; y += 2 * c;
		    c =  *(cp -  *p++ ); x -= c; y += 2 * c;
		    c =  *(cp -  *p++ ); y += 2 * c;
		    c =  *(cp -  *p++ ); x += c; y += 2 * c;
		    c =  *(cp -  *p); x += 2 * c; y += 2 * c;
		    p += 76 - 3;

		    c =  *(cp -  *p++ ); x -= c; y += 3 * c;
		    c =  *(cp -  *p++ ); y += 3 * c;
		    c =  *(cp -  *p); x += c; y += 3 * c;

		    z = sqrt((float)((x * x) + (y * y)));
		    if (z > (9.000000000000000e-01 * (float)n))
		    {   
			do_symmetry = 0;
			if (x == 0)
			    z = 1.000000000000000e+06;
			else 
			    z = ((float)y) / ((float)x);
			if (z < 0) { z =  -z; w =  -1;
			}
			else 

#line 169 "susan_edges.sc"
			    w = 1;
			if (z < 5.000000000000000e-01) { a = 0; b = 1;
			}
			else 

#line 171 "susan_edges.sc"
			{    if (z > 2.000000000000000e+00) { a = 1; b = 0;
			    }
			    else 

#line 172 "susan_edges.sc"
			    {    if (w > 0) { a = 1; b = 1;
				}
				else 

#line 173 "susan_edges.sc"
				{    a =  -1; b = 1;
				}
			    }
			}

#line 174 "susan_edges.sc"
			if ((m > r[(i + a) * 76 + j + b]) && (m >= r[(i - a) * 76 + j - b]) && 
			    (m > r[(i + (2 * a)) * 76 + j + (2 * b)]) && (m >= r[(i - (2 * a)) * 76 + j - (2 * b)]))
			    mid[i * 76 + j] = 1;
		    }
		    else 
			do_symmetry = 1;
		}
		else 
		    do_symmetry = 1;

		if (do_symmetry == 1)
		{   
		    p = in1 + (i - 3) * 76 + j - 1;
		    x = 0; y = 0; w = 0;

#line 193 "susan_edges.sc"
		    c =  *(cp -  *p++ ); x += c; y += 9 * c; w += 3 * c;
		    c =  *(cp -  *p++ ); y += 9 * c;
		    c =  *(cp -  *p); x += c; y += 9 * c; w -= 3 * c;
		    p += 76 - 3;

		    c =  *(cp -  *p++ ); x += 4 * c; y += 4 * c; w += 4 * c;
		    c =  *(cp -  *p++ ); x += c; y += 4 * c; w += 2 * c;
		    c =  *(cp -  *p++ ); y += 4 * c;
		    c =  *(cp -  *p++ ); x += c; y += 4 * c; w -= 2 * c;
		    c =  *(cp -  *p); x += 4 * c; y += 4 * c; w -= 4 * c;
		    p += 76 - 5;

		    c =  *(cp -  *p++ ); x += 9 * c; y += c; w += 3 * c;
		    c =  *(cp -  *p++ ); x += 4 * c; y += c; w += 2 * c;
		    c =  *(cp -  *p++ ); x += c; y += c; w += c;
		    c =  *(cp -  *p++ ); y += c;
		    c =  *(cp -  *p++ ); x += c; y += c; w -= c;
		    c =  *(cp -  *p++ ); x += 4 * c; y += c; w -= 2 * c;
		    c =  *(cp -  *p); x += 9 * c; y += c; w -= 3 * c;
		    p += 76 - 6;

		    c =  *(cp -  *p++ ); x += 9 * c;
		    c =  *(cp -  *p++ ); x += 4 * c;
		    c =  *(cp -  *p); x += c;
		    p += 2;
		    c =  *(cp -  *p++ ); x += c;
		    c =  *(cp -  *p++ ); x += 4 * c;
		    c =  *(cp -  *p); x += 9 * c;
		    p += 76 - 6;

		    c =  *(cp -  *p++ ); x += 9 * c; y += c; w -= 3 * c;
		    c =  *(cp -  *p++ ); x += 4 * c; y += c; w -= 2 * c;
		    c =  *(cp -  *p++ ); x += c; y += c; w -= c;
		    c =  *(cp -  *p++ ); y += c;
		    c =  *(cp -  *p++ ); x += c; y += c; w += c;
		    c =  *(cp -  *p++ ); x += 4 * c; y += c; w += 2 * c;
		    c =  *(cp -  *p); x += 9 * c; y += c; w += 3 * c;
		    p += 76 - 5;

		    c =  *(cp -  *p++ ); x += 4 * c; y += 4 * c; w -= 4 * c;
		    c =  *(cp -  *p++ ); x += c; y += 4 * c; w -= 2 * c;
		    c =  *(cp -  *p++ ); y += 4 * c;
		    c =  *(cp -  *p++ ); x += c; y += 4 * c; w += 2 * c;
		    c =  *(cp -  *p); x += 4 * c; y += 4 * c; w += 4 * c;
		    p += 76 - 3;

		    c =  *(cp -  *p++ ); x += c; y += 9 * c; w -= 3 * c;
		    c =  *(cp -  *p++ ); y += 9 * c;
		    c =  *(cp -  *p); x += c; y += 9 * c; w += 3 * c;

		    if (y == 0)
			z = 1.000000000000000e+06;
		    else 
			z = ((float)x) / ((float)y);
		    if (z < 5.000000000000000e-01) { a = 0; b = 1;
		    }
		    else 

#line 248 "susan_edges.sc"
		    {    if (z > 2.000000000000000e+00) { a = 1; b = 0;
			}
			else 

#line 249 "susan_edges.sc"
			{    if (w > 0) { a =  -1; b = 1;
			    }
			    else 

#line 250 "susan_edges.sc"
			    {    a = 1; b = 1;
			    }
			}
		    }

#line 251 "susan_edges.sc"
		    if ((m > r[(i + a) * 76 + j + b]) && (m >= r[(i - a) * 76 + j - b]) && 
			(m > r[(i + (2 * a)) * 76 + j + (2 * b)]) && (m >= r[(i - (2 * a)) * 76 + j - (2 * b)]))
			mid[i * 76 + j] = 2;
		}
	    }
	}

    printf("start send r, in2 and mid\n");
    port_r.send(r, 76 * 95 * sizeof(int));
    printf("r is sent\n");
    port_mid1.send(mid, 76 * 95 * sizeof(unsigned char));
    printf("mid1 is sent\n");
    port_in2.send(in1, 76 * 95 * sizeof(unsigned char));
    printf("in2 is sent\n");
}

#line 835 "susan_edge_detector.cc"
susan_thin::susan_thin(unsigned int _idcnt, i_receiver (&port_r), i_receiver (&port_mid1), i_sender (&port_mid2))
    : _specc::behavior(_idcnt), port_r(port_r), port_mid1(port_mid1), port_mid2(port_mid2)
{   /* nothing */
}

susan_thin::~susan_thin(void)
{   /* nothing */
}

#line 19 "susan_thin.sc"
void susan_thin::main(void)
{   
    printf("start susan thin\n");
    port_r.receive(r, 76 * 95 * sizeof(int));
    printf("r is received\n");
    port_mid1.receive(mid, 76 * 95 * sizeof(unsigned char));
    printf("mid1 is received\n");
    for(i = 4; i < 95 - 4; i++ )
	for(j = 4; j < 76 - 4; j++ )
	    if (mid[i * 76 + j] < 8)
	    {   
		centre = r[i * 76 + j];

		mp = mid + (i - 1) * 76 + j - 1;

		n = ( *mp < 8) + 
		( *(mp + 1) < 8) + 
		( *(mp + 2) < 8) + 
		( *(mp + 76) < 8) + 
		( *(mp + 76 + 2) < 8) + 
		( *(mp + 76 + 76) < 8) + 
		( *(mp + 76 + 76 + 1) < 8) + 
		( *(mp + 76 + 76 + 2) < 8);

		if (n == 0)
		    mid[i * 76 + j] = 100;

		if ((n == 1) && (mid[i * 76 + j] < 6))
		{   

		    l[0] = r[(i - 1) * 76 + j - 1]; l[1] = r[(i - 1) * 76 + j]; l[2] = r[(i - 1) * 76 + j + 1];
		    l[3] = r[(i) * 76 + j - 1]; l[4] = 0; l[5] = r[(i) * 76 + j + 1];
		    l[6] = r[(i + 1) * 76 + j - 1]; l[7] = r[(i + 1) * 76 + j]; l[8] = r[(i + 1) * 76 + j + 1];

		    if (mid[(i - 1) * 76 + j - 1] < 8) { l[0] = 0; l[1] = 0; l[3] = 0; l[2] *= 2;
			l[6] *= 2; l[5] *= 3; l[7] *= 3; l[8] *= 4;
		    }
		    else 

#line 55 "susan_thin.sc"
		    {    if (mid[(i - 1) * 76 + j] < 8) { l[1] = 0; l[0] = 0; l[2] = 0; l[3] *= 2;
			    l[5] *= 2; l[6] *= 3; l[8] *= 3; l[7] *= 4;
			}
			else 

#line 57 "susan_thin.sc"
			{    if (mid[(i - 1) * 76 + j + 1] < 8) { l[2] = 0; l[1] = 0; l[5] = 0; l[0] *= 2;
				l[8] *= 2; l[3] *= 3; l[7] *= 3; l[6] *= 4;
			    }
			    else 

#line 59 "susan_thin.sc"
			    {    if (mid[(i) * 76 + j - 1] < 8) { l[3] = 0; l[0] = 0; l[6] = 0; l[1] *= 2;
				    l[7] *= 2; l[2] *= 3; l[8] *= 3; l[5] *= 4;
				}
				else 

#line 61 "susan_thin.sc"
				{    if (mid[(i) * 76 + j + 1] < 8) { l[5] = 0; l[2] = 0; l[8] = 0; l[1] *= 2;
					l[7] *= 2; l[0] *= 3; l[6] *= 3; l[3] *= 4;
				    }
				    else 

#line 63 "susan_thin.sc"
				    {    if (mid[(i + 1) * 76 + j - 1] < 8) { l[6] = 0; l[3] = 0; l[7] = 0; l[0] *= 2;
					    l[8] *= 2; l[1] *= 3; l[5] *= 3; l[2] *= 4;
					}
					else 

#line 65 "susan_thin.sc"
					{    if (mid[(i + 1) * 76 + j] < 8) { l[7] = 0; l[6] = 0; l[8] = 0; l[3] *= 2;
						l[5] *= 2; l[0] *= 3; l[2] *= 3; l[1] *= 4;
					    }
					    else 

#line 67 "susan_thin.sc"
					    {    if (mid[(i + 1) * 76 + j + 1] < 8) { l[8] = 0; l[5] = 0; l[7] = 0; l[6] *= 2;
						    l[2] *= 2; l[1] *= 3; l[3] *= 3; l[0] *= 4;
						}
					    }
					}
				    }
				}
			    }
			}
		    }

#line 71 "susan_thin.sc"
		    for(y = 0; y < 3; y++ )
			for(x = 0; x < 3; x++ )
			    if (l[y + y + y + x] > m) { m = l[y + y + y + x]; a = y; b = x;
			    }
		    if (m > 0)
		    {   
			if (mid[i * 76 + j] < 4)
			    mid[(i + a - 1) * 76 + j + b - 1] = 4;
			else 
			    mid[(i + a - 1) * 76 + j + b - 1] = mid[i * 76 + j] + 1;
			if ((a + a + b) < 3)
			{   
			    i += a - 1;
			    j += b - 2;
			    if (i < 4) i = 4;
			    if (j < 4) j = 4;
			}
		    }
		}

		if (n == 2)
		{   
		    b00 = mid[(i - 1) * 76 + j - 1] < 8;
		    b02 = mid[(i - 1) * 76 + j + 1] < 8;
		    b20 = mid[(i + 1) * 76 + j - 1] < 8;
		    b22 = mid[(i + 1) * 76 + j + 1] < 8;
		    if (((b00 + b02 + b20 + b22) == 2) && ((b00 | b22) & (b02 | b20)))
		    {   
			if (b00)
			{   
			    if (b02) { x = 0; y =  -1;
			    }
			    else 

#line 102 "susan_thin.sc"
			    {    x =  -1; y = 0;
			    }
			}
			else  {
			    if (b02) { x = 1; y = 0;
			    }
			    else 

#line 107 "susan_thin.sc"
			    {    x = 0; y = 1;
			    }
			} if (((float)r[(i + y) * 76 + j + x] / (float)centre) > 7.000000000000000e-01)
			{   
			    if (((x == 0) && (mid[(i + (2 * y)) * 76 + j] > 7) && (mid[(i + (2 * y)) * 76 + j - 1] > 7) && (mid[(i + (2 * y)) * 76 + j + 1] > 7)) || 
				((y == 0) && (mid[(i) * 76 + j + (2 * x)] > 7) && (mid[(i + 1) * 76 + j + (2 * x)] > 7) && (mid[(i - 1) * 76 + j + (2 * x)] > 7)))
			    {   
				mid[(i) * 76 + j] = 100;
				mid[(i + y) * 76 + j + x] = 3;
			    }
			}
		    }
		    else 
		    {   
			b01 = mid[(i - 1) * 76 + j] < 8;
			b12 = mid[(i) * 76 + j + 1] < 8;
			b21 = mid[(i + 1) * 76 + j] < 8;
			b10 = mid[(i) * 76 + j - 1] < 8;

#line 145 "susan_thin.sc"
			if (((b01 + b12 + b21 + b10) == 2) && ((b10 | b12) & (b01 | b21)) && 
			    ((b01 & ((mid[(i - 2) * 76 + j - 1] < 8) | (mid[(i - 2) * 76 + j + 1] < 8))) | (b10 & ((mid[(i - 1) * 76 + j - 2] < 8) | (mid[(i + 1) * 76 + j - 2] < 8))) | 
				(b12 & ((mid[(i - 1) * 76 + j + 2] < 8) | (mid[(i + 1) * 76 + j + 2] < 8))) | (b21 & ((mid[(i + 2) * 76 + j - 1] < 8) | (mid[(i + 2) * 76 + j + 1] < 8)))))
			{   
			    mid[(i) * 76 + j] = 100;
			    i-- ;
			    j -= 2;
			    if (i < 4) i = 4;
			    if (j < 4) j = 4;
			}
		    }
		}

		if (n > 2)
		{   
		    b01 = mid[(i - 1) * 76 + j] < 8;
		    b12 = mid[(i) * 76 + j + 1] < 8;
		    b21 = mid[(i + 1) * 76 + j] < 8;
		    b10 = mid[(i) * 76 + j - 1] < 8;
		    if ((b01 + b12 + b21 + b10) > 1)
		    {   
			b00 = mid[(i - 1) * 76 + j - 1] < 8;
			b02 = mid[(i - 1) * 76 + j + 1] < 8;
			b20 = mid[(i + 1) * 76 + j - 1] < 8;
			b22 = mid[(i + 1) * 76 + j + 1] < 8;
			p1 = b00 | b01;
			p2 = b02 | b12;
			p3 = b22 | b21;
			p4 = b20 | b10;

			if (((p1 + p2 + p3 + p4) - ((b01 & p2) + (b12 & p3) + (b21 & p4) + (b10 & p1))) < 2)
			{   
			    mid[(i) * 76 + j] = 100;
			    i-- ;
			    j -= 2;
			    if (i < 4) i = 4;
			    if (j < 4) j = 4;
			}
		    }
		}
	    }
    printf("start to send mid2\n");
    port_mid2.send(mid, 76 * 95 * sizeof(unsigned char));
    printf("mid2 is sent\n");
}

#line 1044 "susan_edge_detector.cc"
write_image::write_image(unsigned int _idcnt, i_receiver (&port_in3), i_sender (&port_out_monitor))
    : _specc::behavior(_idcnt), port_in3(port_in3), port_out_monitor(port_out_monitor)
{   /* nothing */
}

write_image::~write_image(void)
{   /* nothing */
}

#line 13 "write_image.sc"
void write_image::main(void)
{   

    port_in3.receive(in3_buffer, 76 * 95 * sizeof(char));
    port_out_monitor.send(in3_buffer, 76 * 95 * sizeof(char));
}

#line 1062 "susan_edge_detector.cc"
void _scc_bit4_err_handle(
    const _bit4& bit4vec)
{   
    char temp_bits[1024], *p;
    p=bit2str(2,&temp_bits[1023], bit4vec);
    _specc::abort(
	"ERROR:\t Casting a bit4 vector failed \n"
	"Bit4 vector contains X/Z values %s\n"
	"Simulation aborted.\n", p);
	
}

//////////////////////////////////////////////////////////////////////
// End of file susan_edge_detector.cc
//////////////////////////////////////////////////////////////////////
